#!/usr/bin/env python3

import logging
import os
import shlex
import subprocess
import sys
import typing
from typing import List, Optional, Dict

logging.basicConfig(level=os.getenv("LOG_LEVEL", "WARNING"))


def get_labels(cls, default) -> Optional[List[str]]:
    if default is not None or cls is None:
        return default

    if 'typing' in sys.modules and issubclass(cls, typing.NamedTuple):
        return list(cls._field_types.keys())

    # collections.namedtuple
    if hasattr(cls, "_fields"):
        return list(cls._fields)

    return None


def lines_to_records(lines, fs = None, labels = None, cls = None):
    if fs is None:
        if cls is None:
            return lines  # type: List[str]
        return [cls(line) for line in lines]  # type: List[cls]
    rows: List[List[str]] = [line.split(fs) for line in lines]

    labels = get_labels(cls, labels)
    if labels is None:
        if cls is None:
            return rows  # type: List[List[str]]
        return [cls(*fields) for fields in rows]  # type: List[cls]

    records: List[Dict[str, str]] = [dict(zip(labels, fields)) for fields in rows]
    if cls is None:
        return list(records)  # type: List[Dict[str, str]]

    return [cls(**record) for record in records]  # type: List[cls]


def git(cmd, *args, fs=None, labels=None, cls=None, check=True, **kwargs):
    quoted_args = " ".join(shlex.quote(arg) for arg in args)
    logging.info(f'> git {cmd} {quoted_args}')
    result = subprocess.run(["git", cmd, *args], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    if len(result.stderr) != 0:
        try:
            logging.warning(result.stderr.decode())
        except:
            logging.warning(result.stderr)
    try:
        stdout = result.stdout.decode()
        logging.debug(stdout)
    except Exception as e:
        logging.error("Can't decode stdout")
        logging.error(result.stdout)
        raise e

    if check:
        result.check_returncode()
    else:
        return None

    lines = stdout.splitlines()

    return lines_to_records(lines, fs, labels, cls)


def branch(*args, format=None, **kwargs):
    if format:
        return git("branch", "--format", format, *args, **kwargs)
    else:
        return git("branch", *args, **kwargs)


def config(*args):
    result = git("config", '--default', '', ".".join(args))
    if len(result) == 1:
        return result[0]
    else:
        return None


def get_push(branch):
    pushremote = config("branch", branch, "pushremote")
    if pushremote:
        return pushremote

    pushdefault = config("remote", "pushdefault")
    if pushdefault:
        return pushdefault

    remote = config("branch", branch, "remote")
    return remote


class LocalBranch(typing.NamedTuple):
    refname: str = "refname:lstrip=2"
    upstream: str = "upstream:remotename"
    upstream_ref: str = "upstream"
    upstream_track: str = "upstream:track"
    push: str = "push:remotename"
    push_ref: str = "push"
    push_track: str = "push:track"


local_branches: List[LocalBranch] = branch(
    format=":".join(f"%({atom})" for atom in LocalBranch._field_defaults.values()),
    fs=":",
    cls=LocalBranch)

lose_trackings = [br for br in local_branches if br.push_track == "[gone]" or br.upstream_track == "[gone]"]

print("Gone tracking branches:")
for branch in lose_trackings:
    x = ["", branch.refname]
    if branch.push_track == "[gone]":
        x.extend(["push=", branch.push_ref])
    if branch.upstream_track == "[gone]":
        x.extend(["fetch=", branch.upstream_ref])
    print(*x)

# push가 gone이면 upstream/master를 확인
# upstream이 gone이면 upstream/master를 확인
